











import 'dart:async';
import 'package:cocages/services/decharge_services.dart';
import 'package:cocages/services/sync_agent_service.dart';
import 'package:cocages/services/sync_decharg_cours_service.dart';
import 'package:cocages/services/sync_decharg_table_service.dart';
import 'package:cocages/services/sync_tonnage_canne_broyer_par_tas.dart';
import 'package:flutter/material.dart';
import 'package:cocages/auth/services/login_services.dart';
import 'package:cocages/auth/views/login_screen.dart';
import 'package:cocages/views/appbar.dart';
import 'package:cocages/views/cours_canne.dart';
import 'package:cocages/views/sidebar.dart';
import 'package:cocages/views/table_canne.dart';
import 'package:google_fonts/google_fonts.dart';

class Home extends StatefulWidget {
  const Home({super.key});

  @override
  State<Home> createState() => _HomeState();
}

class _HomeState extends State<Home> {
  int _currentIndexValue = 0;
  bool _isLoading = true;
  Timer? _timerSync;
  Timer? _timerUpdating;
  

  @override
  void initState() {
    super.initState();
    _checkUserConnection();
    _startSyncDonneeTimer();
    _startTimerUpdatedPoidsP2();
  }

  @override
    void dispose() {
      _timerSync?.cancel(); // Annuler le Timer de synchronisation
      _timerUpdating?.cancel(); // Annuler le Timer de mise à jour de Poids P2
      super.dispose();
    }


  // Lancer le timer pour la synchronisation des donnee chaque 5minutes
  void _startSyncDonneeTimer() {
    _timerSync = Timer.periodic(const Duration(seconds: 10), (timer) async {
      if (await _thereAreSynchronisation()){
        _synchroniserDonnee();
      }
    });
  }

  
  // Lancer le timerd de recuperation du poids de la deuxime pesee des camions decharger chaque 
  void _startTimerUpdatedPoidsP2() {
    _timerUpdating = Timer.periodic(const Duration(seconds: 10), (timer) {
      _updtatePoidsP2();
    });
  }

  //permet de verifier s'il y'a une synchronisation avant de le faire (sera utiliser lorsque le timer va arriver)
  Future<bool> _thereAreSynchronisation() async {
    bool agentSyncNeeded = await thereAreSynchronisationForAgent();
    bool dechargerCoursSyncNeeded = await thereAreSynchronisationForDechargerCours();
    bool dechargerTableSyncNeeded = await thereAreSynchronisationForDechargerTable();
    bool tableCanneSyncNeeded = await thereAreSynchronisationForTableCanne();

    // Si une quelconque synchronisation est nécessaire, `syncNeeded` devient vrai
    return agentSyncNeeded || dechargerCoursSyncNeeded || dechargerTableSyncNeeded || tableCanneSyncNeeded;
    
  }


  //Methode qui annulera le timer de synchronisation actuel et le redémarrera (sera utile lors de la synchronisation manuelle dans la sidebar)
  void _resetSyncTimer() {
    _timerSync?.cancel(); // Annuler le timer actuel
    _startSyncDonneeTimer(); // Redémarrer le timer
  }

  //me perlettra d'annuler le timer(minuteur) de synchronisation et de mise a jour du poidsP2 periodique après deconnexion dans la sidebar
  void _cancelSyncAndUpdatingP2Timer(){
    _timerSync?.cancel(); // arrete le timer de synvhronisation
    _timerUpdating?.cancel(); //arrete le timer de recuperation du poids de la deuxime pesee des camions decharger

  }

  //me permettra de redemarer le timer de mise a jour du poids P2 apres mise a jour manuel 
  void _cancelUpdatingP2Timer(){
    _timerUpdating?.cancel();
    _updtatePoidsP2();
  }


  //verifier si l'utilisateur a une session ou pas
  Future<void> _checkUserConnection() async {
    bool connected = await userIsInSession();
    if (!connected) {
      // Annuler les timers de synchronisation avant de rediriger l'utilisateur vers la page de connexion
      _timerSync?.cancel();
      _timerUpdating?.cancel();

      // Rediriger vers la page de connexion
      Navigator.of(context).pushReplacement(MaterialPageRoute(
        builder: (context) => const LoginScreen(),
      ));
    } else {
      setState(() {
        _isLoading = false;
      });
    }
  }


  @override
  Widget build(BuildContext context) {
    if (_isLoading) {
      return const Scaffold(
        body: Center(child: CircularProgressIndicator()),
      );
    }

    return Scaffold(
      appBar: const AppbarView(),
      drawer: Sidebar(
        synchroniserManuellement: _synchroniserDonnee,
        resetSyncTimer: _resetSyncTimer,
        cancelSyncAndUpdatingTimer: _cancelSyncAndUpdatingP2Timer,
      ),
      bottomNavigationBar: BottomNavigationBar(
        currentIndex: _currentIndexValue,
        type: BottomNavigationBarType.fixed,
        selectedItemColor: Colors.blue,
        unselectedItemColor: Colors.black,
        selectedFontSize: 22,
        unselectedFontSize: 18,
        iconSize: 30,
        elevation: 80,
        backgroundColor: Colors.white,
        items: const [
          BottomNavigationBarItem(icon: Icon(Icons.home), label: 'Table à Canne'),
          BottomNavigationBarItem(icon: Icon(Icons.dashboard_customize_outlined), label: 'Cours à Canne'),
        ],
        onTap: (index) => setState(() {
          _currentIndexValue = index;
        }),
      ),
      body: screenList[_currentIndexValue],
    );
  }

  List<Widget> get screenList => [
        TableCanne(updateP2Timer: _cancelUpdatingP2Timer,),
        CoursCanne(updateP2Timer: _cancelUpdatingP2Timer,),
      ];

  // Fonction pour afficher les messages en precisant le temps que cela doit faire
  void _showMessageWithTime(String message, int time) {
    ScaffoldMessenger.of(context).showSnackBar(
      SnackBar(content: Text(message, style: GoogleFonts.poppins(fontSize: 19),), duration: Duration(milliseconds: time),),
    );
  }


  Future<void> _updtatePoidsP2() async {
    String updated = await getPoidsP2FromFPESEE(); 
    if (updated == "error"){    
      _showMessageWithTime("La Mise a jour du poids P2 camions déchargés à echoué . Veuillez vérifier également votre connexion internet.",6000);
    } 
    // else if (updated == "") {
    //   _showMessageWithTime("La Recuperation du poids de la deuxieme pesee des camons déchargés effectuée avec succès",4000);

    // }
    // else{
    //   _showMessageWithTime("Les Poids de la deuxieme pesee des camions dechargés ont été recuperé",4000);
    // }
  }

  //faire la synchronisation
  Future<void> _synchroniserDonnee() async {
    bool allSuccess = true; //permet de voir si la snchronisation c'est fait sans echecs pour un cas. par defaut on le suppose
    //bool thereAreSynchronisation = false; //permet de savoir s'il y'a eu une synchronisation ou pas on va avec le faite que no

    //avec cette maniere il executera toute les synchronisation qu'il y'a a faire, si un echoue on continue mais a la fin on precise que la synchronisation n'a pas ete fait cela peut etre du a un qui ne fonctionne pas ou que les serveurs sont ete
    try {
      if (await thereAreSynchronisationForAgent()) {
        //print('synchro pour agent');
        allSuccess &= await synchroniserAgent();
      }

      if (await thereAreSynchronisationForDechargerCours()) {
        //print('synchro pour les dechar dans la cour');

        allSuccess &= await synchroniserDonneeDechargerCours();
      }

      if (await thereAreSynchronisationForDechargerTable()) {
        //print('synchro pour les dechar direct sur la table');

        allSuccess &= await synchroniserDonneeDechargerTable();
      }

      if (await thereAreSynchronisationForTableCanne()) {

        //print('synchro pour les dechar par tas sur la table');
        allSuccess &= await synchroniserDonneeTableCanne();
      }

      if (allSuccess) {
        _showMessageWithTime('Synchronisation effectuée avec succès', 4000);
        
      } else {
        _showMessageWithTime("La synchronisation a échoué. Veuillez vérifier votre connexion internet.", 6000);
      }
    } catch (e) {
      _showMessageWithTime("La synchronisation a échoué. Veuillez vérifier votre connexion internet $e.", 6000);
    }
  }

}




